WARNING: work in progress. (tested on Linux only)

Two ways:

HOWTO:
======================

1) provide support for an async implementation:

  impl 1 native):
  ================

      compile my async version of Vim (github.com/MarcWeber/vim branch "work").
      (-) doesn't work in gui very well yet. That's why its not used in that case

  impl 2 c_executable):
  ================

      compile C/vim-addon-async-helper.c
      (-) requires client server (X connection or the like
      (-) 20ms delay (vim -> app)

  impl 3 possible others):
  ================
  - mzscheme (racket)
    implementation using threads. That would be the only solution working
    everywhere.
    (+) portable)
    (-) not implemented yet
    (_) very view users have mzscheme support
 
  - python (also calling back into Vim cause its not threadsafe, but passing
    data to Python could be done easily)

2) Then try one of the examples in the comments above async#LogToBuffer(ctx)
  ( -> autoload/async.vim )

  Example:
  call async#LogToBuffer({'cmd':'python -i', 'move_last':1, 'prompt': '^>>> $'})
  then type:
    oprint "abc"<space><cr>

credits:
================
Thanks to:

  * Bart Trojanowski who provided the initial C implementation of the Vim patch
    (Thus he did most of the work)

  * Sergey Khorev who provided the initial racket (scheme implementation) code


documentation:
==================================
Everything is still in a flux.
This is a copy paste of the async.txt draft which will be part of the Vim patch.
So replace async_exec by async#Exec.

async_exec({ctx})   -- starts an asynchronous process


  context keys which will be used:
  ================================
    - cmd: the command to be executed. 

    /* idea (which I removed) because split() runs reasonable fast:
      - aslines (optional): if set a list of lines will be passed to the
                  functions receiving stdout/ err
                  You should not change this setting
    */

    - receive({type}, content) (optional):
        function receiving stdout/err. If aslines evaluates to true content will
        be a list of lines. type is always "stdout". (Providing a way for
        receiving stderr/out separately could be provided - but because Vim is
        polling the descriptors only once in a while it may be better to let
        the OS merge both streams)

    - started()    (optional) : called when process was started successfully
                                Now self.pid should contain the process id

    - terminated() (optional) : called when the process terminated (or when it was killed)
                                Now self.status should contain the exit status

  context keys which will be assigned:
  ====================================
    - pid    : the process pid
    - status : the process exit status.

  Note: You must not change pid yourself

async_kill({ctx})                -- kills an asynchronous process
async_list()                     -- returns list of processes
async_write({ctx}, {string})     -- pass string to stdin of context

TODO:
async_read_until({ctx}, {string} -- read bytes from stdout until one of the
                                    chars contained in string is found
                                 -- this way you can read lines etc easily.
                                    Don't know yet how useful it is. This way
                                    you can implement "blocking" read features
                                    if you have to.
                                    Example use case would be completion.
                                    Another way would be returning no
                                    completions restarting completion task if
                                    cursor didn't move and the completion
                                    results are received by the specified
                                    receive function

When a process dies it will be removed from the list.
So keep your own references if you have to.

VIML CODE EXAMPLE: >
  fun! s:Add(s)
    let l = [{'text': string(a:s)}]
    call setqflist(l, 'a')
  endf

  " ctx 1
  let ctx = { 'cmd' : 'nr=1; while read f; do nr=`expr $nr + 1`; sleep 1; echo $nr $f - pong; if [ $nr == 5 ]; then break; fi; done; exit 12' }
  fun ctx.receive(type, text)
    call s:Add(string(a:text))
    call async_write(self, "ping\n")
  endf

  fun ctx.started()
    call s:Add("ctx1: process started. pid:  ". self.pid)
  endf

  fun ctx.terminated()
    call s:Add("ctx1: process died. status (should be 12): ". self.status)
  endf

  call async_exec(ctx)
  call async_write(ctx, "ping\n")


  " ctx2 2
  let ctx2 = { 'cmd' : 'find / | while read f; do echo $f; sleep 1; done' }

  fun ctx2.receive(type, text)
    call s:Add('ctx22: '.string(a:text))
  endf

  fun ctx2.started()
    call s:Add("ctx22: process started. pid:  ". self.pid)
  endf

  fun ctx2.terminated()
    call s:Add("ctx22: process died. status:  ". self.status)
  endf
  call async_exec(ctx2)



